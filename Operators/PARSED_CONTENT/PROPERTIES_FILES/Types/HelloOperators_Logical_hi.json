{
    "Logical_key1": "नाम: लॉजिकल ऑपरेटर\nसबमिशन_टाइप: यूआरएल\n",
    "Logical_key2": "### तार्किक `Operator`(और, या, नहीं) :-\n\n\n",
    "Logical_key3": "`Logical `संचालकों`��:�`c3RhdGVtZW50cw==`+���a�����`b3BlcmF0b3Jz`��>3B����`cHl0aG9u`\u001b�?(m4���\u0018a����\u001b�t3M\u0006\u001bm\f`b3BlcmF0b3Jz`������`VHJ1ZQ ==``RmFsc2U=`�`v3��m\u0001\u001ba��wy��\f`b3BlcmF0b3Jz`ӝ4\u0018`cHl0aG9u`3B��o�\u001b��",
    "Logical_key4": "(तार्किक `operators` हमें निर्णय लेने में मदद करता है और सुनिश्चित करता है कि आगे बढ़ने के लिए आवश्यक शर्तें पूरी होती हैं।)\n",
    "Logical_key5": "`and :-` इस `operator` का उपयोग यह जांचने के लिए किया जाता है कि यह जिन दोनों स्थितियों पर काम करता है वह `true` होनी चाहिए। यदि दोनों स्थितियां `true` हैं, तो ***`and`*** `true` वापस आ जाएगी, अन्यथा (भले ही 1 शर्त `false` हो या दोनों स्थितियां `false` हों), `output` `false` होगा। उदाहरण : मुझे फलों का सलाद बनाने के लिए सेब और संतरे चाहिए। यहाँ, उनमें से केवल एक ही मेरा सलाद पूरा नहीं करेगा, मुझे दोनों चाहिए।\n",
    "Logical_key6": "**उदाहरण :-**\n",
    "Logical_key7": "`Output :-`\n",
    "Logical_key8": "`��<��`\n",
    "Logical_key9": "**उदाहरण :-**\n",
    "Logical_key10": "यहाँ, संख्या और 1 दोनों `true` हैं तो उत्तर 1 है।\n",
    "Logical_key11": "अगर `input` 0 है तो `output` 0 होगा क्योंकि एक शर्त `false` है।\n",
    "Logical_key12": "`or :-` इस `operator` का उपयोग यह जांचने के लिए किया जाता है कि यह जिन शर्तों पर काम करता है उनमें से एक `true` होनी चाहिए। यदि दोनों स्थितियां `false` हैं, ***`or`*** `false` लौटाएगी, अन्यथा (यदि 1 शर्त `false` है या दोनों स्थितियां `true` हैं), तो `output` dHJ1ZQ==`��}�\u0001�د6\u0018m�\u001b�4\u001b��o\u0006\u001b��\u001bA�ؠt�a������",
    "Logical_key13": "**उदाहरण :-**\n",
    "Logical_key14": "`Output :-`\n",
    "Logical_key15": "`�mF3�`\n",
    "Logical_key16": "**उदाहरण :-**\n",
    "Logical_key17": "`Output :-`\n",
    "Logical_key18": "`apple`\n",
    "Logical_key19": "**`and` और `or` `operators` उनके उत्तर के निर्धारण के समय मान का एक `output` देंगे। उदाहरण के लिए,\n`1 and 2` `output` को 2 के रूप में देता है क्योंकि जांच करते समय कि दोनों स्थितियां सही हैं, `output` या `and` का उत्तर निर्धारित किया जा सकता है जब उसने दूसरी स्थिति की जांच की हो।\nइसी तरह, `0 and 2` के लिए `output` 0 है क्योंकि पहली शर्त की जांच के समय, `and` `operator` का उत्तर `false` होना निर्धारित है क्योंकि पहली शर्त `false=`.**\n",
    "Logical_key20": "**`\u0007r` के लिए, `and` के समान, `1 or 2` 1 का `output` उत्पन्न करेगा, भले ही पहली शर्त `true` हो, `output` से `or` निर्धारित किया जाता है वहां। `0 or \"\"` `(empty ` स्ट्रिंग`)` देगा क्योंकि `output` 0 नहीं है क्योंकि `output` दूसरी शर्त पर निर्धारित किया जाता है**।\n",
    "Logical_key21": "`not :-` ***`not`*** `operator` का उपयोग विपरीत स्थिति प्राप्त करने के लिए किया जाता है। तो यह स्थिति के `output` के विपरीत `output` देता है।\n",
    "Logical_key22": "**उदाहरण :-**\n",
    "Logical_key23": "`Output :-`\n",
    "Logical_key24": "`��<��`\nc वास्तव में b से बड़ा है इसलिए स्थिति c > b है `true` लेकिन इसके सामने `not` जोड़ने पर विपरीत `output`, यानी `false` मिलता है।\n",
    "Logical_key25": "**उदाहरण :-**\n",
    "Logical_key26": "`Output :-`\n",
    "Logical_key27": "`�mF3�`\n"
}