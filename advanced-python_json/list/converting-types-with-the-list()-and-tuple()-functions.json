[
	{
		"component": "header",
		"variant": 1,
		"value": "Converting Types with the list() and tuple() Functions"
	},
	{
		"component": "text",
		"value": "Just like how str(42) will return '42', the <span style=\"\">string</span> representation of the <span style=\"\">integer</span> 42, the functions list() and tuple() will return list and tuple versions of the values passed to them. Enter the following into the interactive <span style=\"\">shell</span>, and notice that the return value is of a different data type than the value passed:"
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": ">>> tuple(['cat', 'dog', 5])<br>('cat', 'dog', 5)<br>>>> list(('cat', 'dog', 5))<br>['cat', 'dog', 5]<br>>>> list('hello')<br>['h', 'e', 'l', 'l', 'o']"
	},
	{
		"component": "text",
		"value": "Converting a tuple to a list is handy if you need a mu<span style=\"\">tab</span>le version of a tuple value."
	},
	{
		"component": "header",
		"variant": 1,
		"value": "References"
	},
	{
		"component": "text",
		"value": "As you’ve seen, <span style=\"\">variables</span> store <span style=\"\">strings</span> and <span style=\"\">integer</span> values. Enter the following into the interactive <span style=\"\">shell</span>:"
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": ">>> spam = 42<br>>>> cheese = spam<br>>>> spam = 100<br>>>> spam<br>100<br>>>> cheese<br>42"
	},
	{
		"component": "text",
		"value": "You assign 42 to the spam <span style=\"\">variable</span>, and then you copy the value in spam and assign it to the <span style=\"\">variable</span> cheese. When you later change the value in spam to 100, this doesn’t affect the value in cheese. This is because spam and cheese are different <span style=\"\">variables</span> that store different values."
	},
	{
		"component": "text",
		"value": "But lists don’t work this way. When you assign a list to a <span style=\"\">variable</span>, you are actually assigning a list reference to the <span style=\"\">variable</span>. A reference is a value that points to some bit of data, and a list reference is a value that points to a list. Here is some <span style=\"\">code</span> that will make this distinction easier to understand. Enter this into the interactive <span style=\"\">shell</span>:"
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": "❶ >>> spam = [0, 1, 2, 3, 4, 5]<br>❷ >>> cheese = spam<br>❸ >>> cheese[1] = 'Hello!'<br>   >>> spam<br>   [0, 'Hello!', 2, 3, 4, 5]<br>   >>> cheese<br>   [0, 'Hello!', 2, 3, 4, 5]"
	},
	{
		"component": "text",
		"value": "This might look odd to you. The <span style=\"\">code</span> changed only the cheese list, but it seems that both the cheese and spam lists have changed."
	},
	{
		"component": "text",
		"value": "When you create the list ❶, you assign a reference to it in the spam <span style=\"\">variable</span>. But the next line ❷ copies only the list reference in spam to cheese, not the list value itself. This means the values stored in spam and cheese now both refer to the same list. There is only one underlying list because the list itself was never actually copied. So when you modify the first element of cheese ❸, you are modifying the same list that spam refers to."
	},
	{
		"component": "text",
		"value": "Remember that <span style=\"\">variables</span> are like boxes that contain values. The previous figures in this chapter show that lists in boxes aren’t exactly accurate because list <span style=\"\">variables</span> don’t actually contain lists—they contain references to lists. (These references will have ID numbers that <span style=\"\">Python</span> uses internally, but you can ignore them.) Using boxes as a metaphor for <span style=\"\">variables</span>, Figure 4-4 shows what happens when a list is assigned to the spam <span style=\"\">variable</span>."
	},
	{
		"component": "text",
		"value": "spam = [0, 1, 2, 3, 4, 5] stores a reference to a list, not the actual list."
	},
	{
		"component": "text",
		"value": "Then, in Figure 4-5, the reference in spam is copied to cheese. Only a new reference was created and stored in cheese, not a new list. Note how both references refer to the same list."
	},
	{
		"component": "text",
		"value": "spam = cheese copies the reference, not the list."
	},
	{
		"component": "text",
		"value": "When you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list. You can see this in Figure"
	},
	{
		"component": "text",
		"value": "cheese[1] = 'Hello!' modifies the list that both <span style=\"\">variables</span> refer to."
	},
	{
		"component": "text",
		"value": "<span style=\"\">Variables</span> will contain references to list values rather than list values themselves. But for <span style=\"\">strings</span> and <span style=\"\">integer</span> values, <span style=\"\">variables</span> simply contain the <span style=\"\">string</span> or <span style=\"\">integer</span> value. <span style=\"\">Python</span> uses references whenever <span style=\"\">variables</span> must store values of mu<span style=\"\">tab</span>le data types, such as lists or dictionaries. For values of immu<span style=\"\">tab</span>le data types such as <span style=\"\">strings</span>, <span style=\"\">integers</span>, or tuples, <span style=\"\">Python</span> <span style=\"\">variables</span> will store the value itself."
	},
	{
		"component": "text",
		"value": "Although <span style=\"\">Python</span> <span style=\"\">variables</span> technically contain references to list or dictionary values, people often casually say that the <span style=\"\">variable</span> contains the list or dictionary."
	},
	{
		"component": "header",
		"variant": 1,
		"value": "Passing References"
	},
	{
		"component": "text",
		"value": "References are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter <span style=\"\">variables</span>. For lists (and dictionaries, which I’ll describe in the next chapter), this means a copy of the reference is used for the parameter. To see the consequences of this, open a new <span style=\"\">file</span> <span style=\"\">editor</span> window, enter the following <span style=\"\">code</span>, and <span style=\"\">save</span> it as passingReference.py:"
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": "def eggs(someParameter):<br>    someParameter.append('Hello')<br><br>spam = [1, 2, 3]<br>eggs(spam)<br>print(spam)"
	},
	{
		"component": "text",
		"value": "Notice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place, directly. When run, this program produces the following <span style=\"\">output</span>:"
	},
	{
		"component": "text",
		"value": "[1, 2, 3, 'Hello']<br>Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned."
	},
	{
		"component": "text",
		"value": "Keep this behavior in mind: Forgetting that <span style=\"\">Python</span> handles list and dictionary <span style=\"\">variables</span> this way can lead to confusing bugs."
	}
]