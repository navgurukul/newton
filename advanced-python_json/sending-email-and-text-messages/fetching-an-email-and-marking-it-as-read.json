[
	{
		"component": "header",
		"variant": 1,
		"value": "Fetching an Email and Marking It As Read"
	},
	{
		"component": "text",
		"value": "Once you have a list of UIDs, you can call the IMAPClient object’s fetch() method to get the actual email content."
	},
	{
		"component": "text",
		"value": "The list of UIDs will be fetch()’s first argument. The second argument should be the list ['BODY[]'], which tells fetch() to download all the body content for the emails specified in your UID list."
	},
	{
		"component": "text",
		"value": "Let’s continue our interactive <span style=\"\">shell</span> example."
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": ">>> rawMessages = imapObj.fetch(UIDs, ['BODY[]'])<br>>>> import pprint<br>>>> pprint.pprint(rawMessages)"
	},
	{
		"component": "text",
		"value": "{40040: {'BODY[]': 'Delivered-To: "
	},
	{
		"component": "text",
		"value": "my<i>email</i>address@gmail.com"
	},
	{
		"component": "text",
		"value": "\\r\\n'<br>                   'Received: by 10.76.71.167 with SMTP id '<br>--snip--<br>                   '\\r\\n'<br>                   '------=<i>Part</i>6000970<i>707736290.1404819487066--\\r\\n',<br>         'SEQ': 5430}}<br>Import pprint and pass the return value from fetch(), stored in the <span style=\"\">variable</span> rawMessages, to pprint.pprint() to “pretty print” it, and you’ll see that this return value is a nested dictionary of messages with UIDs as the <span style=\"\">keys</span>. Each message is stored as a dictionary with two <span style=\"\">keys</span>: 'BODY[]' and 'SEQ'. The 'BODY[]' <span style=\"\">key</span> maps to the actual body of the email. The 'SEQ' <span style=\"\">key</span> is for a sequence number, which has a similar role to the UID. You can safely ignore it.<br>As you can see, the message content in the 'BODY[]' <span style=\"\">key</span> is pretty unintelligible. It’s in a format called RFC 822, which is designed for IMAP servers to read. But you don’t need to understand the RFC 822 format; later in this chapter, the pyzmail module will make sense of it for you.<br>When you selected a folder to search through, you called select</i>folder() with the readonly=<span style=\"\">True</span> <span style=\"\">key</span>word argument. Doing this will prevent you from accidentally deleting an email—but it also means that emails will not get marked as read if you fetch them with the fetch() method. If you do want emails to be marked as read when you fetch them, you will need to pass readonly=<span style=\"\">False</span> to select<i>folder(). If the selected folder is already in readonly mode, you can reselect the current folder with another call to select</i>folder(), this time with the readonly=<span style=\"\">False</span> <span style=\"\">key</span>word argument:"
	},
	{
		"component": "code",
		"type": "python",
		"title": "",
		"value": ">>> imapObj.select_folder('INBOX', readonly=False)"
	}
]