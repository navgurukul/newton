{
	"checking-for-errors_key1": "# Checking for `Errors`\n\n",
	"checking-for-errors_key2": "As you’ve seen, the Response object has a status_`code` attribute that can be checked against requests.`codes`.ok to see whether the download succeeded. A simpler way to check for success is to call the raise_for_status() method on the Response object. This will raise an exception if there was an `error` downloading the `file` and will do nothing if the download succeeded. Enter the following into the interactive `shell`:\n",
	"checking-for-errors_key3": "Traceback (most recent call last):\n  `File` \"<py`shell`#138>\", line 1, in <module>\n    res.raise_for_status()\n  `File` \"C:\\`Python3`4\\lib\\site-packages\\requests\\models.py\", line 773, in raise_for_status\n    raise HTTP`Error`(http_`error`_msg, response=self)\nrequests.exceptions.HTTP`Error`: 404 Client `Error`: Not Found\nThe raise_for_status() method is a good way to ensure that a program halts if a bad download occurs. This is a good thing: You want your program to stop as soon as some unexpected `error` happens. If a failed download isn’t a deal breaker for your program, you can wrap the raise_for_status() line with try and except `statements` to handle this `error` case without crashing.\n",
	"checking-for-errors_key4": "import requests\nres = requests.get('<span><a href=\"http://inventwith`python`.com/page_that_does_not_exist'\">http://inventwith`python`.com/page_that_does_not_exist'</a></span>)\ntry:\n    res.raise_for_status()\nexcept Exception as exc:\n    print('There was a problem: %s' % (exc))\nThis raise_for_status() method call causes the program to `output` the following:\n",
	"checking-for-errors_key5": "There was a problem: 404 Client `Error`: Not Found\nAlways call raise_for_status() after calling requests.get(). You want to be sure that the download has actually worked before your program continues.\n"
}