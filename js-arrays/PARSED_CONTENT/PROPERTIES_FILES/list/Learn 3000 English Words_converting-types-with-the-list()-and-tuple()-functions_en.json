{
	"converting-types-with-the-list()-and-tuple()-functions_key1": "# Converting Types with the list() and tuple() Functions\n\n",
	"converting-types-with-the-list()-and-tuple()-functions_key2": "Just like how str(42) will return '42', the `string` representation of the `integer` 42, the functions list() and tuple() will return list and tuple versions of the values passed to them. Enter the following into the interactive `shell`, and notice that the return value is of a different data type than the value passed:\n",
	"converting-types-with-the-list()-and-tuple()-functions_key3": "Converting a tuple to a list is handy if you need a mu`tab`le version of a tuple value.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key4": "# References\n\n",
	"converting-types-with-the-list()-and-tuple()-functions_key5": "As you’ve seen, `variables` store `strings` and `integer` values. Enter the following into the interactive `shell`:\n",
	"converting-types-with-the-list()-and-tuple()-functions_key6": "You assign 42 to the spam `variable`, and then you copy the value in spam and assign it to the `variable` cheese. When you later change the value in spam to 100, this doesn’t affect the value in cheese. This is because spam and cheese are different `variables` that store different values.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key7": "But lists don’t work this way. When you assign a list to a `variable`, you are actually assigning a list reference to the `variable`. A reference is a value that points to some bit of data, and a list reference is a value that points to a list. Here is some `code` that will make this distinction easier to understand. Enter this into the interactive `shell`:\n",
	"converting-types-with-the-list()-and-tuple()-functions_key8": "This might look odd to you. The `code` changed only the cheese list, but it seems that both the cheese and spam lists have changed.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key9": "When you create the list ❶, you assign a reference to it in the spam `variable`. But the next line ❷ copies only the list reference in spam to cheese, not the list value itself. This means the values stored in spam and cheese now both refer to the same list. There is only one underlying list because the list itself was never actually copied. So when you modify the first element of cheese ❸, you are modifying the same list that spam refers to.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key10": "Remember that `variables` are like boxes that contain values. The previous figures in this chapter show that lists in boxes aren’t exactly accurate because list `variables` don’t actually contain lists—they contain references to lists. (These references will have ID numbers that `Python` uses internally, but you can ignore them.) Using boxes as a metaphor for `variables`, Figure 4-4 shows what happens when a list is assigned to the spam `variable`.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key11": " -->\nspam = [0, 1, 2, 3, 4, 5] stores a reference to a list, not the actual list.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key12": "Then, in Figure 4-5, the reference in spam is copied to cheese. Only a new reference was created and stored in cheese, not a new list. Note how both references refer to the same list.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key13": " -->\nspam = cheese copies the reference, not the list.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key14": "When you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list. You can see this in Figure\n",
	"converting-types-with-the-list()-and-tuple()-functions_key15": " -->\ncheese[1] = 'Hello!' modifies the list that both `variables` refer to.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key16": "`Variables` will contain references to list values rather than list values themselves. But for `strings` and `integer` values, `variables` simply contain the `string` or `integer` value. `Python` uses references whenever `variables` must store values of mu`tab`le data types, such as lists or dictionaries. For values of immu`tab`le data types such as `strings`, `integers`, or tuples, `Python` `variables` will store the value itself.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key17": "Although `Python` `variables` technically contain references to list or dictionary values, people often casually say that the `variable` contains the list or dictionary.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key18": "# Passing References\n\n",
	"converting-types-with-the-list()-and-tuple()-functions_key19": "References are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter `variables`. For lists (and dictionaries, which I’ll describe in the next chapter), this means a copy of the reference is used for the parameter. To see the consequences of this, open a new `file` `editor` window, enter the following `code`, and `save` it as passingReference.py:\n",
	"converting-types-with-the-list()-and-tuple()-functions_key20": "Notice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place, directly. When run, this program produces the following `output`:\n",
	"converting-types-with-the-list()-and-tuple()-functions_key21": "[1, 2, 3, 'Hello']\nEven though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\n",
	"converting-types-with-the-list()-and-tuple()-functions_key22": "Keep this behavior in mind: Forgetting that `Python` handles list and dictionary `variables` this way can lead to confusing bugs.\n"
}