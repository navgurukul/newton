{
	"exception-handling_key1": "# Exception Handling\n\n",
	"exception-handling_key2": "Right now, getting an `error`, or exception, in your `Python` program means the entire program will crash. You don’t want this to happen in real-world programs. Instead, you want the program to detect `errors`, handle them, and then continue to run.\n",
	"exception-handling_key3": "For example, consider the following program, which has a “divide-by-zero” `error`. Open a new `file` `editor` window and enter the following `code`, saving it as zeroDivide.py:\n",
	"exception-handling_key4": "We’ve defined a function called spam, given it a parameter, and then printed the value of that function with various parameters to see what happens. This is the `output` you get when you run the previous `code`:\n",
	"exception-handling_key5": "21.0\n3.5\nTraceback (most recent call last):\n  `File` \"C:/zeroDivide.py\", line 6, in <module>\n    print(spam(0))\n  `File` \"C:/zeroDivide.py\", line 2, in spam\n    return 42 / divideBy\nZeroDivision`Error`: division by zero\nA ZeroDivision`Error` happens whenever you try to divide a number by zero. From the line number given in the `error` message, you know that the return `statement` in spam() is causing an `error`.\n",
	"exception-handling_key6": "`Errors` can be handled with try and except `statements`. The `code` that could potentially have an `error` is put in a try clause. The program execution moves to the start of a following except clause if an `error` happens.\n",
	"exception-handling_key7": "You can put the previous divide-by-zero `code` in a try clause and have an except clause contain `code` to handle what happens when this `error` occurs.\n",
	"exception-handling_key8": "When `code` in a try clause causes an `error`, the program execution immediately moves to the `code` in the except clause. After running that `code`, the execution continues as normal. The `output` of the previous program is as follows:\n",
	"exception-handling_key9": "21.0\n3.5\n`Error`: Invalid argument.\nNone\n42.0\nNote that any `errors` that occur in function calls in a try block will also be caught. Consider the following program, which instead has the spam() calls in the try block:\n",
	"exception-handling_key10": "When this program is run, the `output` looks like this:\n",
	"exception-handling_key11": "21.0\n3.5\n`Error`: Invalid argument.\nThe reason print(spam(1)) is never `execute`d is because once the execution jumps to the `code` in the except clause, it does not return to the try clause. Instead, it just continues moving down as normal.\n"
}