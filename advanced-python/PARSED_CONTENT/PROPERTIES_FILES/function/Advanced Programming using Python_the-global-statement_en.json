{
	"the-global-statement_key1": "# The global `Statement`\n\n",
	"the-global-statement_key2": "If you need to modify a global `variable` from within a function, use the global `statement`. If you have a line such as global eggs at the top of a function, it tells `Python`, “In this function, eggs refers to the global `variable`, so don’t create a local `variable` with this name.” For example, type the following `code` into the `file` `editor` and `save` it as sameName2.py:\n",
	"the-global-statement_key3": "When you run this program, the final print() call will `output` this:\n",
	"the-global-statement_key4": "spam\nBecause eggs is declared global at the top of spam() ❶, when eggs is set to 'spam' ❷, this assignment is done to the globally scoped eggs. No local eggs `variable` is created.\n",
	"the-global-statement_key5": "There are four rules to tell whether a `variable` is in a local scope or global scope:\n",
	"the-global-statement_key6": "If a `variable` is being used in the global scope (that is, outside of all functions), then it is always a global `variable`.\n",
	"the-global-statement_key7": "If there is a global `statement` for that `variable` in a function, it is a global `variable`.\n",
	"the-global-statement_key8": "Otherwise, if the `variable` is used in an assignment `statement` in the function, it is a local `variable`.\n",
	"the-global-statement_key9": "But if the `variable` is not used in an assignment `statement`, it is a global `variable`.\n",
	"the-global-statement_key10": "To get a better feel for these rules, here’s an example program. Type the following `code` into the `file` `editor` and `save` it as sameName3.py:\n",
	"the-global-statement_key11": "In the spam() function, eggs is the global eggs `variable`, because there’s a global `statement` for eggs at the beginning of the function ❶. In bacon(), eggs is a local `variable`, because there’s an assignment `statement` for it in that function ❷. In ham() ❸, eggs is the global `variable`, because there is no assignment `statement` or global `statement` for it in that function. If you run sameName3.py, the `output` will look like this:\n",
	"the-global-statement_key12": "spam\nIn a function, a `variable` will either always be global or always be local. There’s no way that the `code` in a function can use a local `variable` named eggs and then later in that same function use the global eggs `variable`.\n",
	"the-global-statement_key13": "# Note\n\n",
	"the-global-statement_key14": "If you ever want to modify the value stored in a global `variable` from in a function, you must use a global `statement` on that `variable`.\n",
	"the-global-statement_key15": "If you try to use a local `variable` in a function before you assign a value to it, as in the following program, `Python` will give you an `error`. To see this, type the following into the `file` `editor` and `save` it as sameName4.py:\n",
	"the-global-statement_key16": "If you run the previous program, it produces an `error` message.\n",
	"the-global-statement_key17": "Traceback (most recent call last):\n  `File` \"C:/test3784.py\", line 6, in <module>\n    spam()\n  `File` \"C:/test3784.py\", line 2, in spam\n    print(eggs) # `ERROR`!\nUnboundLocal`Error`: local `variable` 'eggs' referenced before assignment\nThis `error` happens because `Python` sees that there is an assignment `statement` for eggs in the spam() function ❶ and therefore considers eggs to be local. But because print(eggs) is `execute`d before eggs is assigned anything, the local `variable` eggs doesn’t exist. `Python` will not fall back to using the global eggs `variable` ❷.\n",
	"the-global-statement_key18": "Functions as “Black Boxes”\n",
	"the-global-statement_key19": "Often, all you need to know about a function are its `inputs` (the parameters) and `output` value; you don’t always have to burden yourself with how the function’s `code` actually works. When you think about functions in this high-level way, it’s common to say that you’re treating the function as a “black box.”\n",
	"the-global-statement_key20": "This idea is fundamental to modern programming. Later chapters in this book will show you several modules with functions that were written by other people. While you can take a peek at the source `code` if you’re curious, you don’t need to know how these functions work in order to use them. And because writing functions without global `variables` is encouraged, you usually don’t have to worry about the function’s `code` interacting with the rest of your program.\n"
}